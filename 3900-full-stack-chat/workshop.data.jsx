<>
{/*. id */}
workshops-full-stack-chat
{/*. name */}
Full stack chat (ReactJS + Express)
{/*. exercises */}

{/*. desc */}

Run the project and answer the following questions

{/*. q */}
Load the project in your browser. Signup and login.

{/*. q */}
Write three messages as one user then three messages as another user.

{/*. q */}
Close the browser and reopen it and login again. Are the messages still there?










{/*. source */}
{/*. file-path */}
server.js
{/*. 1 */}
Our backend is going to use express and multer. It will run on port 4000

{/*. 2 */}
This code comes from the boilerplate mentioned in class. You'll be using
      that boilerplate to make the project. It does several things. 1) It creates an endpoint for the build directory, which is
      generated by webpack from the /src directory. 2) Any request to an unknown path will send back the index.html file. This
      is to make things work with react router. If a user directly enters a url in the
      address bar, say /signup, we want them to load the index.html

{/*. 3 */}
It's also going to use cookie-parser so that the
server can give the user a session id and the user can reuse at every HTTP request

{/*. 4 */}
This array stores all the chat messages

{/*. 5 */}
This object associates usernames with passwords. It is used in the /login and /signup endpoints

{/*. 6 */}
This object associates session ids with usernames. It is used in the /login and /newmessage endpoint

{/*. 7 */}
This function generates random session ids. It is used in /signup

{/*. 8 */}
The signup endpoint associates a username with a password. Right now, we don't even check if the username already exists. You'll need to fix this later.

{/*. 9 */}
As a convenience, we declare some variables

{/*. 10 */}
We make the association between the username and the password in the passwords object. We console.log the passwords object for debugging purposes.

{/*. 11 */}
This endpoint always responds with a success message in the HTTP response body

{/*. 12 */}
The login endpoint receives fetch requests and verifies that the password supplied matches the password used during signup. The console logs are for debugging purposes.

{/*. 13 */}
We declare some variables as a convenience

{/*. 14 */}
We get the password that was used during signup. The console.log is for debugging purposes

{/*. 15 */}
We check to see if the password supplied matches the one used during signup

{/*. 16 */}
If the password is correct, we generate a new session id and we associate the session id with the
      username supplied in the sessions object

{/*. 17 */}
We set the 'sid' cookie with a value of <code>{`sessionId`}</code> so that we can identify the user every time
      they send an HTTP request to the server. This is used in the /newmessage endpoint

{/*. 18 */}
We send back a success message since the password was correct

{/*. 19 */}
We return. Is this return necessary?

{/*. 20 */}
We can only get to the line if the password was incorrect (why?), so we send a message to indicate that the login did not succeed

{/*. 21 */}
The /newmessage endpoint receives an HTTP request every time the user sends a message to the chat

{/*. 22 */}
We need to get the username of the person who sent the message. We do this by first getting the session id and then using the session id
       to get the username using the sessions object which is populated in the /login endpoint

{/*. 23 */}
The message is in the msg property. There is a reference to <code>{`msg`}</code> in the ChatForm component on the frontend

{/*. 24 */}
Now that we have the username and the message, we can create a new object with those two pieces of information and then add that object to the messages array.

{/*. 25 */}
We send a message to the client notifying that the process was successful.

{/*. 26 */}
The /messages endpoint always sends back all the messages. Since it is an array, we need to convert it to a string before sending it.









{/*. source */}
{/*. file-path */}
src/index.jsx
{/*. 1 */}
We import the standard libraries

{/*. 2 */}
We're also going to import Provider from react-redux and our store from store.js

{/*. 3 */}
We place the Provider as the top level node in our
       virtual DOM so that we can use redux everywhere. The value of the store prop
       is our store. The store has two main attributes: an initial value and a reducer. See reducer.js
       for more information.









{/*. source */}
{/*. file-path */}
src/store.js
{/*. 1 */}
In this file we create and export the store. We need to use createStore to create the store.

{/*. 2 */}
The reducer is a function that takes a state and an action. An action is just an object with a <code>{`type`}</code> property.
            It potentially returns a new object. The state of the store will then refer to this new object.
            To activate the reducer, a component needs to call this.props.dispatch and pass the action.
            The reducer then gets called with the current state of the store and the action. The reducer
            is referenced when the store is created (in later slides)

            

{/*. 3 */}
If the <code>{`type`}</code> of the action is <code>{`"login-success"`}</code> then we create and return a new object with
            the same properties as state with the loggedIn property set to true. Looking at Login.jsx, we see that
            this happens when the user successfully logs in.
            

{/*. 4 */}
If the <code>{`type`}</code> of the action is <code>{`"set-messages"`}</code>, then we create a new object
            with the msgs property referring to action.messages. Looking at ChatMessages.jsx, we see
            that this will be an array.
            

{/*. 5 */}
If the type is unrecognized, return the state as is. This is useful since
            redux sends an action with type <code>{`"@@INIT"`}</code> when the store is created.

            

{/*. 6 */}
We create the store. We need to provide the initial state of the store and the reducer

{/*. 7 */}
This argument lets you use redux developer tools, which is very, very useful. You can just
            copy paste it.









{/*. source */}
{/*. file-path */}
src/App.jsx
{/*. 1 */}
We'll be importing connect from react-redux so that our
         component can access data in the store. Specifically, we'll want to know whether
         or not the user has logged in yet

{/*. 2 */}
In the virtual DOM, The UnconnectedApp nodes will be a child of
         connect(UnconnectedApp) nodes.
         Through this arragement, the connect(UnconnectedApp) component
         will give props to UnconnectedApp nodes.
         Namely, the lgin prop. The value of that prop depends
         on the store. More specifically, it depends on the loggedIn property
         of the store. Initially, state.loggedIn is false, but it
         changes to true when the user logs in
         

{/*. 3 */}
The value of this.props.lgin reflects whether or not a user has logged
            in. If the user has logged in, you want to display the chat messages and the
            form to send a message to the chat. If the user has not logged in,
            you want to display signup and login forms.
            









{/*. source */}
{/*. file-path */}
src/Login.jsx
{/*. 1 */}
The UnconnectedLogin nodes will each be a child of connect(UnconnectedLogin) in the virtual DOM. The reason is that
we want to be able to dispatch actions to the reducer. This is why we use connect and this is why
it is the return value of connect that is exported. The only prop that will be passed to UnconnectedLogin is dispatch
since we're not passing a mapStateToProps function. We will call dispatch when the user
successfully logs in and we need to update the store to reflect this fact. This will happen when the form is submitted 

{/*. 2 */}
The handleSubmit method starts off in the normal way

{/*. 3 */}
We make the fetch request. In the body of the fetch request we put the information needed to successfully log in the user.
Look for req.body.username and req.body.password on the backend to see how this information is used.

{/*. 4 */}
response refers to a response object, but what we're really interested in is the response body
                We can use the text method, which returns a promise that resolves to the response body. We then use
                await. This suspends the function until the promise is resolved.

{/*. 5 */}
It is always a good idea to console log the response body in case
            there's an error.

{/*. 6 */}
If the login was not a success, alert the user. 

{/*. 7 */}
If the login is successful, dispatch an object with type <code>{`"login-success"`}</code>. Looking at the reducer
in store.js, we see that it modifies the loggedIn property of the state of the store.









{/*. source */}
{/*. file-path */}
src/Signup.jsx
{/*. 1 */}
This component is a standard signup form

{/*. 2 */}
When the form is submitted, send an HTTP request to the /signup POST endpoint with the username
            and password in the HTTP request body.
            You can look at the server code to see how req.body.username and req.body.password are used.









{/*. source */}
{/*. file-path */}
src/ChatForm.jsx
{/*. 1 */}
Standard form component. The only state is <code>{`message`}</code>. The only thing that is different from
            for this component is the onSubmit function

{/*. 2 */}
The onSubmit function starts off by calling preventDefault to prevent
            the page from reloading. Then we're creating a FormData instance so that we can use it
            in the fetch request to set the HTTP request body. The credentials property with a value of <code>{`"include"`}</code> is important since
            it tells fetch to send the Cookie header. We're sending the HTTP request body and the cookie
            header to the POST /newmessage endpoint. In the body we have the message. The backend
            will find out who this message is from by looking up the username using the cookie.









{/*. source */}
{/*. file-path */}
src/ChatMessages.jsx
{/*. 1 */}
This UnconnectedChatMessages component
             will display all the messages in the chat. To do so, it needs data from the store.
             To get this data, we pass it to connect, which creates a new component called connect(UnconnectedChatMessages).
             In the virtual DOM, every node of this component will have an UnconnectedChatMessages child.
             Furthermore, it will pass a <code>{`messages`}</code> prop to that child. The value of that prop is <code>{`state.msgs`}</code>, which changes
             every time the reducer receives an object with a <code>{`type`}</code> prop with a value of <code>{`set-messages`}</code>. It also
             passes a <code>{`dispatch`}</code> prop to the UnconnectedChatMessages child, which enables the child to send
             actions to the reducer.
             

{/*. 2 */}
We define the componentDidMount method. If a method has
            this name then it will get called after the first render. Inside
            the body of this method we will use setInterval to continuously
            get messages from the server

{/*. 3 */}
We define the function that makes a fetch request. As we will see, it will get called at regular intervals

{/*. 4 */}
From the response object we can get a promise that resolves to the response body using the text method.
            We can then use await. The function will resume once the http response body becomes available.

{/*. 5 */}
It is always a good idea to console log the response body in case there's an error or an unxpected response. 

{/*. 6 */}
The first thing to do is to parse the HTTP response. Looking at the backend, we see that
            it is the result of calling JSON.stringify on an array, so the result of JSON.parse will be an array

{/*. 7 */}
We dispatch an object with <code>{`type`}</code> <code>{`"set-messages"`}</code> and <code>{`messages`}</code> <code>{`"parsed"`}</code> so that
            we can set the messages in the store.

{/*. 8 */}
Thanks to setInterval, the whole process will happen every 500ms

{/*. 9 */}
The render method returns a div

{/*. 10 */}
Inside the div we put all the messages as li elements wrapped in a ul element









{/*. exercises */}

{/*. desc */}

Go over these questions to deepen your understanding

{/*. q */}
Why do we need a backend for this project? Could we do without one?

{/*. q */}
Sue's never used this chat web app before. She signs up, logs in and posts a message. 
        In the correct order, which endpoints did she send messages to?

{/*. q */}
Why do we need to use cookies for this project?

{/*. q */}
In your own words, what does each endpoint on the backend do?

{/*. q */}
For each endpoint, find the fetch request that sends an HTTP request to that endpoint

{/*. q */}
Which fetch requests have callbacks to handle the HTTP response? Why do some fetch requests have a callback
        but others don't?

{/*. q */}
Why do we need redux for this project?

{/*. q */}
Which components read from the store and which components modify the store and which do both?

{/*. q */}
When do we use connect and what is it for?

{/*. q */}
How are the following terms related? dispatch, action, reducer, store

{/*. q */}
Why do we need to call fetch at every 500ms in this project? Is there an alternative way to achieve the same result?

{/*. q */}
How many forms are there and what does each form do?

{/*. q */}
How is the value of the lgin prop of UnconnectedApp related to the store? Where is this relationship described?

{/*. q */}
Some connected components have a mapStateToProps but others don't. Why is that?










{/*. exercises */}

{/*. desc */}

Extend the program you created

{/*. q */}
Like previous workshops, make a summary and then write the code from the summary. Make the summary as vaugue as possible.

{/*. q */}
Right now the user can sign up with the same username twice. Fix this issue
    Hint: You'll need to modify the /signup endpoint and the Signup component

{/*. q */}
Right now, using postman, a person can get the messages of the chat
    without ever having to login. fix this situation.

{/*. q */}
Right now the user has to login after he signs up. Change it so that he is logged in as soon as he signs up.

{/*. q */}
Add a logout button

{/*. q */}
Right now all the chat messages are sent from the backend to the user.
     Imagine if there are thousands of messages?
    Change it so that only the 20 latest messages are sent.

{/*. q */}
Sometimes people say something and then instantly regret it. Add a button so that a user can delete all of their messages.

{/*. q */}
Your users would like to get notified when someone logs in. In the chat, add a message whenever a user joins that notifies everyone that a new user has logged in. 

{/*. q */}
Sometimes it's useful to know when a message has been sent from a particular user. Display the time that the message was sent along with the message.

{/*. q */}
Our users don't want to login every time they come to our site. They want to login once and then not have to login again. Make this happen.

{/*. q */}
Display a list of users who are currently chatting on the left hand side of the chat
    Do not display people who have been inactive for more than 5 minutes
    When you're testing, change it to 3 seconds to make it easier on yourself

{/*. q */}
Make it so that people can put images in the chat

{/*. q */}
Some chatters are so rude that they should be kicked out of the chat.
    
    Create a special account with a username "admin." Whoever has this username has the ability to kick people out of the chat.
    Use window.prompt("who do you want to kick") to get the name of the user you want to kick
    When a user is kicked out, he is automatically logged out and brought back to the login screen
    Everyone in the chat is notified when a user is kicked out

{/*. q */}
(keener question) add direct messaging capabilities

{/*. q */}
 (keener question)
    Add multiple chat rooms. Each chat room should have a name. Any user can create a new chat room.











</>